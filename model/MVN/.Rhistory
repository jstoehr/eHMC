data <- data[, , -dim(data)[3]]
dim(data)
dim(ehmc_sample)
ess_single_chain <- function(f_chain, mu_hat, s2_hat, cutoff = 0.05) {
n <- length(f_chain)
temp <- f_chain - mu_hat
s <- length(initseq(f_chain)$Gamma.con)
# s <- 1
rho_0 <- sum(temp[1:n] * temp[1:n]) / (n * s2_hat)
rho <- rep(0, n - 1)
for(i in seq_len(2 * s - 1)) {
rho[i] <- sum(temp[(i + 1):n] * temp[1:(n - i)]) / ((n - i) * s2_hat)
}
#
# rho[1] <- sum(temp[(s + 1):n] * temp[1:(n - s)]) / ((n - s) * s2_hat)
# while (rho[s] > cutoff && s < n | s < 10) {
#   s <- s + 1
#   rho[s] <- sum(temp[(s + 1):n] * temp[1:(n - s)]) / ((n - s) * s2_hat)
# }
return(list(
rho_0 = rho_0,
rho = rho,
ess = n * n / (n + 2 * sum(((n - 1):1) * rho)),
cutoff_lag = s
))
}
ess_x_chain <- function(f_chain, rho_hat, mu_hat, s2_hat) {
# --- Length of the chain
n <- nrow(f_chain)
# --- Number of chains
n_chain <- ncol(f_chain)
# --- Cutoff
m <- nrow(rho_hat)
mean_per_chain <- colMeans(f_chain)
var_per_chain <- apply(f_chain, 2, var)
# --- Between chain variance
b <- n * var(mean_per_chain)
# --- Within chain variance
w <- mean(var_per_chain)
# --- Variance estimator
var_hat <- ((n - 1) * w + b) / n
# --- Potential scale reduction
r_hat <- sqrt(var_hat / w)
# --- Average auto-correlation
rho_hat_mean <- 1 - (w - rowMeans(rho_hat)) / var_hat
# rho_hat_mean <- rowMeans(rho_hat)
# --- Initial positive sequence estimator <- done in the ess single chain
# m <- length(rho_hat_mean)
# if(m > 1){
#   temp <- rho_hat_mean[seq(1, m, 2)] + rho_hat_mean[seq(2, m, 2)]
#   m <- max(which(temp > 0))
# }
ess <- n * n_chain / (1 + 2 * sum(rho_hat_mean[2:m]))
return(list(w = w, b = b, var_hat = var_hat, r_hat = r_hat, ess = ess))
}
ess_summary <- function(data, mu_hat, s2_hat, cutoff = 0.05) {
# --- Useful input
n <- dim(data)[1]
n_chain <- dim(data)[2]
n_param <- dim(data)[3]
# --- Output
ess_param <- matrix(NA, n_chain, n_param)
x_summary <- data.frame(
w = rep(0, n_param),
b = rep(0, n_param),
var_hat = rep(0, n_param),
r_hat = rep(0, n_param),
x_ess = rep(0, n_param)
)
for (k in 1:n_param) {
rho_0_hat <- numeric(n_chain)
rho_hat <- matrix(NA, n - 1, n_chain)
cutoff <- numeric(n_chain)
# --- Computing the ess per chain for the given parameter
for (j in 1:n_chain) {
ans <- ess_single_chain(data[, j, k], mu_hat[k], s2_hat[k], cutoff)
ess_param[j, k] <- ans$ess
rho_0_hat[j] <- ans$rho_0
rho_hat[, j] <- ans$rho
cutoff[j] <- ans$cutoff_lag
}
# --- Removing the lines after the cutoff
cutoff <- min(cutoff)
rho_hat <- matrix(rho_hat[-((cutoff + 1):(n - 1)), ], nrow = cutoff, ncol = n_chain)
# --- Computing the average ess
ans <- ess_x_chain(data[, , k], rho_hat, mu_hat[k], s2_hat[k])
x_summary[k, 1] <- ans$w
x_summary[k, 2] <- ans$b
x_summary[k, 3] <- ans$var_hat
x_summary[k, 4] <- ans$r_hat
x_summary[k, 5] <- ans$ess
}
return(list(
ess_param = data.frame(ess_param = ess_param),
x_chain_summary = x_summary
))
}
# --- For Rstan
library(rstan)
# --- For hand made parallel computation
library(doParallel)
# ---
library(mcmc)
model_name <- BLP
model_name <- "BLP"
setwd("~/git/eHMC/model/BLP")
# ------ Data specification
source(paste(model_name, "R", sep = "."))
M_type <- "diag_e"
delta <- 0.6
n_chain <- 40
burn <- 2000
cat(delta, "\n")
# --- Loading NUTS long run
load(paste("NUTS", model_name, M_type, "80_long_run_.RData",
sep = "_"
))
ground_truth <- as.matrix(fit)
ground_truth <- ground_truth[, -ncol(ground_truth)]
# --- Moments of the functionnal on the long chain
mu_hat_m1 <- colMeans(ground_truth)
s2_hat_m1 <- apply(ground_truth, 2, var)
temp <- ground_truth * ground_truth
mu_hat_m2 <- colMeans(temp)
s2_hat_m2 <- apply(temp, 2, var)
rm(fit, ground_truth, temp)
# --- Computing NUTS results
cat(delta, "\n")
load("/Users/jstoehr/git/eHMC/model/BLP/NUTS_BLP_diag_e_80_long_run_.RData")
setwd("~/git/eHMC/model/BLP")
load("~/git/eHMC/model/BLP/result_ess_BLP_diag_e_60_.RData")
load("~/git/eHMC/model/BLP/NUTS_BLP_diag_e_60_.RData")
attr(fit@sim$samples[[1]], "args")
sampler_params <- get_sampler_params(fit)
sampler_params
sampler_params[[1]]
sampler_params[[1]]$n_leapfrog__
is.data.frame(sampler_params[[1]])
as.data.frame(sampler_params[[1]])
model_name <- "BLP"
setwd("~/git/eHMC/model/BLP")
load("~/git/eHMC/model/BLP/result_ess_BLP_diag_e_60_.RData")
nuts_result_m1$x_chain_summary
load("~/git/eHMC/model/BLP/NUTS_BLP_diag_e_60_.RData")
print(fit)
out_stan <- print(fit)
nuts_result_m1$x_chain_summary
data <- as.array(fit)
dim(data)
data <- data[, , -dim(data)[3]]
f_chain <- data[, , 1]
dim(f_chain)
model_name <- "BLP"
setwd("~/git/eHMC/model/BLP")
load("result_ess_BLP_diag_e_60_.RData")
load("NUTS_BLP_diag_e_80_long_run_.RData")
ground_truth <- as.matrix(fit)
ground_truth <- ground_truth[, -ncol(ground_truth)]
# --- Moments of the functionnal on the long chain
mu_hat_m1 <- colMeans(ground_truth)
s2_hat_m1 <- apply(ground_truth, 2, var)
temp <- ground_truth * ground_truth
mu_hat_m2 <- colMeans(temp)
s2_hat_m2 <- apply(temp, 2, var)
load("NUTS_BLP_diag_e_60_.RData")
nuts_result_m1$x_chain_summary
out_stan <- print(fit)
data <- as.array(fit)
data <- data[, , -dim(data)[3]]
n <- 20000
n_exp <- 40
k <- 1
f_chain <- data[, , k]
mu_hat <- mu_hat_m1
s2_hat <- s2_hat_m1
rho <- matrix(0, n, n_exp)
rho_0 <- numeric(n_exp)
for (j in 1:n_exp) {
temp <- f_chain[, j] - mu_hat[k]
rho_0[j] <- sum(temp[1:n] * temp[1:n]) / (n * s2_hat)
for(i in seq_len(n - 1)) {
rho[i, j] <- sum(temp[(i + 1):n] * temp[1:(n - i)]) / ((n - i) * s2_hat)
}
}
mean_per_chain <- colMeans(f_chain)
var_per_chain <- apply(f_chain, 2, var)
# --- Between chain variance
b <- n * var(mean_per_chain)
# --- Within chain variance
w <- mean(var_per_chain)
# --- Variance estimator
(var_hat <- ((n - 1) * w + b) / n)
# --- Potential scale reduction
(r_hat <- sqrt(var_hat / w))
rho_mean <- 1 - (w - rowMeans(rho)) / var_hat
n <- 20000
n_exp <- 40
k <- 1
f_chain <- data[, , k]
mu_hat <- mu_hat_m1
s2_hat <- s2_hat_m1
rho <- matrix(0, n, n_exp)
rho_0 <- numeric(n_exp)
for (j in 1:n_exp) {
temp <- f_chain[, j] - mu_hat[k]
rho_0[j] <- sum(temp[1:n] * temp[1:n]) / (n * s2_hat[k])
for(i in seq_len(n - 1)) {
rho[i, j] <- sum(temp[(i + 1):n] * temp[1:(n - i)]) / ((n - i) * s2_hat[k])
}
}
head(rho)
mean_per_chain <- colMeans(f_chain)
var_per_chain <- apply(f_chain, 2, var)
# --- Between chain variance
b <- n * var(mean_per_chain)
# --- Within chain variance
w <- mean(var_per_chain)
# --- Variance estimator
(var_hat <- ((n - 1) * w + b) / n)
# --- Potential scale reduction
(r_hat <- sqrt(var_hat / w))
rho_mean <- 1 - (w - rowMeans(rho)) / var_hat
plot(rho_mean)
plot(rho_mean)
sign(diff(rho_mean))
rho_0
rho_mean <- 1 - w / var_hat + rowMeans(rho)
20000 * 40 / (1 + 2 * rho_mean[1])
print(fit)
20000 * 40 / (1 + 2 * rho_mean[1:3])
20000 * 40 / (1 + 2 * sum(rho_mean[1:3]))
20000 * 40 / (1 + 2 * sum(rho_mean[1:5]))
ehmc_result_m1$x_chain_summary
load("/Users/jstoehr/git/eHMC/model/BLP/eHMC_BLP_diag_e_60_1_.RData")
hist(ehmc_sample[,1])
var(ehmc_sample[,1])
model_name <- "MVN"
load("~/git/eHMC/model/MVN/result_ess_MVN_diag_e_60_.RData")
ehmc_result_m1$x_chain_summary
load("~/git/eHMC/model/MVN/result_ess_MVN_diag_e_80_.RData")
ehmc_result_m1$x_chain_summary
nuts_result_m1$x_chain_summary
load("/Users/jstoehr/git/eHMC/model/BLP/adapt_info_NUTS_BLP_diag_e_60_.RData")
eHMC <- function(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M, data = NULL) {
current_U <- U(theta, data)
dim_theta <- length(theta)
theta <- matrix(theta, n_iter + 1, dim_theta, byrow = TRUE)
ans <- data.frame(
rho = rep(0, n_iter), L = rep(1, n_iter), div = rep(F, n_iter)
)
for (i in 1:n_iter) {
current_v <- as.numeric(chol_M %*% rnorm(dim_theta))
current_K <- current_v %*% (inv_M %*% current_v)
L <- sample(emp_L, 1)
prop <- leapfrog(theta[i, ], current_v, grad_U, eps, L, inv_M, data)
new_U <- U(prop$theta, data)
new_K <- prop$v %*% (inv_M %*% prop$v)
rho <- current_U - new_U + 0.5 * (current_K - new_K)
if (is.na(rho) || rho < log(runif(1))) {
theta[i + 1, ] <- theta[i, ]
} else {
theta[i + 1, ] <- prop$theta
current_U <- new_U
}
ans[i, ] <- c(rho, L, is.na(rho))
}
return(data.frame(theta = theta[-1, ], ans))
}
leapfrog <- function(theta, v, grad_U, eps, L, inv_M, data = NULL) {
new_theta <- theta
new_v <- v - 0.5 * eps * grad_U(theta, data)
for (l in 1:(L - 1)) {
new_theta <- new_theta + eps * as.numeric(inv_M %*% new_v)
new_v <- new_v - eps * grad_U(new_theta, data)
}
new_theta <- new_theta + eps * as.numeric(inv_M %*% new_v)
return(list(
theta = new_theta,
v = new_v - 0.5 * eps * grad_U(new_theta, data)
))
}
single_leapfrog <- function(theta, v, grad_U, eps, inv_M, data) {
new_v <- v - 0.5 * eps * grad_U(theta, data)
new_theta <- theta + eps * as.numeric(inv_M %*% new_v)
new_v <- new_v - 0.5 * eps * grad_U(new_theta, data)
return(list(theta = new_theta, v = new_v))
}
M <- diag(1,3)
inv_M <- solve(M)
chol_M <- t(chol(M))
M
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
M
inv_M
chol_M
1/sqrt(3)
sqrt(3)
load("/Users/jstoehr/git/eHMC/model/BLP/adapt_info_NUTS_BLP_diag_e_60_.RData")
diag(inv_M[1,])
diag(sqrt(inv_M[1,]))
diag(1/sqrt(inv_M[1,]))
eHMC <- function(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M, data = NULL) {
current_U <- U(theta, data)
dim_theta <- length(theta)
theta <- matrix(theta, n_iter + 1, dim_theta, byrow = TRUE)
ans <- data.frame(
rho = rep(0, n_iter), L = rep(1, n_iter), div = rep(F, n_iter)
)
for (i in 1:n_iter) {
current_v <- as.numeric(chol_M %*% rnorm(dim_theta))
current_K <- current_v %*% (inv_M %*% current_v)
L <- sample(emp_L, 1)
prop <- leapfrog(theta[i, ], current_v, grad_U, eps, L, inv_M, data)
new_U <- U(prop$theta, data)
new_K <- prop$v %*% (inv_M %*% prop$v)
rho <- current_U - new_U + 0.5 * (current_K - new_K)
if (is.na(rho) || rho < log(runif(1))) {
theta[i + 1, ] <- theta[i, ]
} else {
theta[i + 1, ] <- prop$theta
current_U <- new_U
}
ans[i, ] <- c(rho, L, is.na(rho))
}
return(data.frame(theta = theta[-1, ], ans))
}
leapfrog <- function(theta, v, grad_U, eps, L, inv_M, data = NULL) {
new_theta <- theta
new_v <- v - 0.5 * eps * grad_U(theta, data)
for (l in 1:(L - 1)) {
new_theta <- new_theta + eps * as.numeric(inv_M %*% new_v)
new_v <- new_v - eps * grad_U(new_theta, data)
}
new_theta <- new_theta + eps * as.numeric(inv_M %*% new_v)
return(list(
theta = new_theta,
v = new_v - 0.5 * eps * grad_U(new_theta, data)
))
}
single_leapfrog <- function(theta, v, grad_U, eps, inv_M, data) {
new_v <- v - 0.5 * eps * grad_U(theta, data)
new_theta <- theta + eps * as.numeric(inv_M %*% new_v)
new_v <- new_v - 0.5 * eps * grad_U(new_theta, data)
return(list(theta = new_theta, v = new_v))
}
eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta) {
return(dnorm(theta[1]) * dnorm(theta[2], 0, sqrt(3)))
}
grad_U <- function(theta) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.01
emp_L <- 10
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta, data = NULL) {
return(dnorm(theta[1]) * dnorm(theta[2], 0, sqrt(3)))
}
grad_U <- function(theta, data = NULL) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.01
emp_L <- 10
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
sample(10, 1)
test <- eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
hist(test[1,])
hist(as.numeric(test[1,]))
hist(as.numeric(test[,1]))
hist(as.numeric(test[,2]))
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta, data = NULL) {
return(- dnorm(theta[1], log = T) - dnorm(theta[2], 0, sqrt(3), log = T))
}
grad_U <- function(theta, data = NULL) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.01
emp_L <- 10
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
test <- eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
hist(test[, 1], freq = F)
hist(test[, 2], freq = F)
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta, data = NULL) {
return(-theta[1]^2/2 - theta[2]^2/6)
}
grad_U <- function(theta, data = NULL) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.01
emp_L <- 10
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
test <- eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
hist(test[, 1], freq = F)
hist(test[, 2], freq = F)
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta, data = NULL) {
return(-theta[1]^2/2 - theta[2]^2/6)
}
grad_U <- function(theta, data = NULL) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.001
emp_L <- 10
M <- diag(c(1,3))
inv_M <- solve(M)
chol_M <- t(chol(M))
test <- eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
hist(test[, 1], freq = F)
hist(test[, 2], freq = F)
theta <- rnorm(2)
n_iter <- 10000
U <- function(theta, data = NULL) {
return(-theta[1]^2/2 - theta[2]^2/6)
}
grad_U <- function(theta, data = NULL) {
return(c(-theta[1], -theta[2]/3))
}
eps <- 0.001
emp_L <- 10
M <- diag(c(1,1))
inv_M <- solve(M)
chol_M <- t(chol(M))
test <- eHMC(theta, n_iter, U, grad_U, eps, emp_L,
inv_M, chol_M)
hist(test[, 1], freq = F)
hist(test[, 2], freq = F)
d <- 2
mu <- rep(0, d)
A <- diag(c(1, 3))
data <- list(d = d, mu = mu, A = A, inv_A = solve(A))
d <- 2
mu <- rep(0, d)
A <- diag(c(1, 3))
data <- list(d = d, mu = mu, A = A, inv_A = solve(A))
fit_ <- stan("MVN.stan",
data = data,
chains = 1,
iter = 22000,
warmup = 2000,
save_dso = FALSE,
verbose = FALSE,
algorithm = "NUTS",
control = list(
adapt_engaged = TRUE, stepsize = 0.01, adapt_delta = delta,
metric = M_type, max_treedepth = 14
)
)
setwd("~/git/eHMC/model/MVN")
d <- 2
mu <- rep(0, d)
A <- diag(c(1, 3))
data <- list(d = d, mu = mu, A = A, inv_A = solve(A))
fit_ <- stan("MVN.stan",
data = data,
chains = 1,
iter = 22000,
warmup = 2000,
save_dso = FALSE,
verbose = FALSE,
algorithm = "NUTS",
control = list(
adapt_engaged = TRUE, stepsize = 0.01, adapt_delta = delta,
metric = M_type, max_treedepth = 14
)
)
d <- 2
mu <- rep(0, d)
A <- diag(c(1, 3))
data <- list(d = d, mu = mu, A = A, inv_A = solve(A))
fit_ <- stan("MVN.stan",
data = data,
chains = 1,
iter = 22000,
warmup = 2000,
save_dso = FALSE,
verbose = FALSE,
algorithm = "NUTS",
control = list(
adapt_engaged = TRUE, stepsize = 0.01, adapt_delta = delta,
metric = M_type, max_treedepth = 14
)
)
